
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async validateYoutubeUrl(url: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_youtube_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchVideoMetadata(url: string) : Promise<Result<VideoMetadata, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_video_metadata", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async extractAudio(url: string, onEvent: TAURI_CHANNEL<ExtractionEvent>) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("extract_audio", { url, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getWaveform(audioPath: string) : Promise<Result<WaveformData, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_waveform", { audioPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async generateWaveformStream(audioPath: string, onEvent: TAURI_CHANNEL<WaveformEvent>) : Promise<Result<WaveformData, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_waveform_stream", { audioPath, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportSample(sourcePath: string, outputPath: string, startTime: number, endTime: number) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_sample", { sourcePath, outputPath, startTime, endTime }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkCachedAudio(videoId: string) : Promise<Result<CachedAudioInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_cached_audio", { videoId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppStats() : Promise<Result<AppStats, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_stats") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analyzeAudioBeats(audioPath: string) : Promise<Result<BeatInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analyze_audio_beats", { audioPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Process an existing audio file (waveform + beat detection).
 * Used when audio is already downloaded (e.g., from cache).
 */
async processAudio(audioPath: string, onEvent: TAURI_CHANNEL<PipelineEvent>) : Promise<Result<PipelineResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("process_audio", { audioPath, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the unified pipeline for fetching and processing audio.
 * 
 * This command:
 * 1. Emits `RequestExtraction` for the frontend to run Pyodide/yt-dlp
 * 2. Waits for extraction progress/completion via `pipeline_notify`
 * 3. Runs FFmpeg commands for audio conversion
 * 4. Runs waveform + beat detection in parallel
 * 5. Reports unified progress throughout
 */
async runPipeline(url: string, onEvent: TAURI_CHANNEL<PipelineEvent>) : Promise<Result<PipelineResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("run_pipeline", { url, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a command to the running pipeline.
 * 
 * Used by the frontend to:
 * - Report extraction progress (`DownloadProgress`)
 * - Signal extraction completion (`ExtractionComplete`)
 * - Signal extraction failure (`ExtractionFailed`)
 */
async pipelineNotify(command: PipelineCommand) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pipeline_notify", { command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getQjsStatus() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_qjs_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFfmpegStatus() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_ffmpeg_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * HTTP request command for Pyodide worker.
 * Routes HTTP requests through native Tauri HTTP client to bypass CORS.
 */
async httpRequest(url: string, method: string, headers: Partial<{ [key in string]: string }>, body: string | null) : Promise<Result<HttpResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("http_request", { url, method, headers, body }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadToFile(url: string, outputPath: string, headers: Partial<{ [key in string]: string }>) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_to_file", { url, outputPath, headers }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Download a file with progress reporting via channel.
 * Progress is throttled to avoid overwhelming the channel (every 100KB or 250ms).
 */
async downloadToFileWithProgress(url: string, outputPath: string, headers: Partial<{ [key in string]: string }>, onProgress: TAURI_CHANNEL<DownloadProgress>) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_to_file_with_progress", { url, outputPath, headers, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async dlopenFfmpeg(command: string, args: string[]) : Promise<Result<FFmpegResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("dlopen_ffmpeg", { command, args }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async ffprobeCapabilities() : Promise<Result<FFmpegResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ffprobe_capabilities") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
appNotification: AppNotification
}>({
appNotification: "app-notification"
})

/** user-defined constants **/



/** user-defined types **/

/**
 * Global app notification event for typesafe event communication
 */
export type AppNotification = { level: NotificationLevel; message: string }
export type AppStats = { cacheSizeMb: number; memoryUsageMb: number }
/**
 * Beat and tempo information extracted from audio
 */
export type BeatInfo = { 
/**
 * Detected BPM (beats per minute)
 */
bpm: number; 
/**
 * Confidence of BPM detection (0.0 - 1.0)
 */
bpmConfidence: number; 
/**
 * Beat positions in seconds
 */
beats: number[]; 
/**
 * Onset positions in seconds (transients/attacks)
 */
onsets: number[] }
export type CachedAudioInfo = { audioPath: string; durationSecs: number; sampleRate: number }
/**
 * Download progress information from http.rs
 */
export type DownloadProgress = { bytesDownloaded: number; totalBytes: number | null; percent: number }
export type ExtractionEvent = { event: "started"; data: { videoId: string } } | { event: "progress"; data: { percent: number; status: string } } | { event: "audioInfo"; data: { sampleRate: number } } | { event: "waveformProgress"; data: { totalPeaks: number } } | { event: "waveformChunk"; data: { peaks: number[]; offset: number } } | { event: "beatInfo"; data: { bpm: number; bpmConfidence: number; beats: number[]; onsets: number[] } } | { event: "completed"; data: { audioPath: string; durationSecs: number } } | { event: "error"; data: { message: string } }
/**
 * FFmpeg command queued by yt-dlp for later execution
 */
export type FFmpegCommand = { id: string; command: string; args: string[]; inputPath: string | null; outputPath: string | null; status: string }
export type FFmpegResult = { exitCode: number; wasAborted: boolean; stdout: string; stderr: string; error: string | null }
export type HttpResponse = { status: number; headers: Partial<{ [key in string]: string }>; body: string }
export type NotificationLevel = "info" | "warning" | "error"
/**
 * Commands sent TO the pipeline FROM the frontend/worker
 */
export type PipelineCommand = 
/**
 * Extraction phase completed successfully
 */
{ command: "extractionComplete"; data: { audioPath: string; ffmpegCommands: FFmpegCommand[] } } | 
/**
 * Extraction phase failed
 */
{ command: "extractionFailed"; data: { message: string } } | 
/**
 * Download progress update (forwarded from http.rs via worker)
 */
{ command: "downloadProgress"; data: { bytesDownloaded: number; totalBytes: number | null } } | 
/**
 * Initializing progress update (yt-dlp is working but no download yet)
 */
{ command: "initializingProgress"; data: { message: string } }
/**
 * Unified pipeline event enum for streaming progress and results
 */
export type PipelineEvent = 
/**
 * Pipeline has started processing
 */
{ event: "started"; data: { url: string; outputPath: string; stages: StageName[] } } | 
/**
 * Progress update from any stage
 */
{ event: "progress"; data: StageProgress } | 
/**
 * Request frontend to run extraction via Pyodide worker
 * Pipeline BLOCKS until it receives ExtractionComplete or ExtractionFailed
 */
{ event: "requestExtraction"; data: { url: string; outputPath: string } } | 
/**
 * Waveform chunk for progressive rendering
 */
{ event: "waveformChunk"; data: { peaks: number[]; offset: number } } | 
/**
 * Waveform generation completed
 */
{ event: "waveformComplete"; data: { peaks: number[]; durationSecs: number; sampleRate: number } } | 
/**
 * Beat detection completed
 */
{ event: "beatDetectionComplete"; data: { bpm: number; bpmConfidence: number; beats: number[]; onsets: number[] } } | 
/**
 * All stages completed successfully
 */
{ event: "completed"; data: PipelineResult } | 
/**
 * A stage failed (fail-fast)
 */
{ event: "error"; data: { stage: StageName; message: string; 
/**
 * Whether this error might be recoverable with retry
 */
recoverable: boolean } }
/**
 * Result of the complete pipeline execution
 */
export type PipelineResult = { audioPath: string; durationSecs: number; sampleRate: number }
/**
 * Names of processing stages in the pipeline with associated weights
 */
export type StageName = 
/**
 * yt-dlp info extraction (indeterminate progress)
 */
"initializing" | 
/**
 * Audio stream download (byte-level progress)
 */
"downloading" | 
/**
 * FFmpeg remux/convert (indeterminate progress)
 */
"converting" | 
/**
 * Waveform peak generation (chunk progress)
 */
"waveform" | 
/**
 * Beat/tempo analysis (indeterminate progress)
 */
"beatDetection"
/**
 * Progress information for a specific stage
 */
export type StageProgress = { stage: StageName; 
/**
 * Progress within this stage (0-100, or -1 for indeterminate)
 */
stagePercent: number; 
/**
 * Overall pipeline progress (0-100)
 */
overallPercent: number; message: string }
export type VideoMetadata = { title: string; authorName: string; authorUrl: string; thumbnailUrl: string; videoId: string }
export type WaveformData = { peaks: number[]; durationSecs: number; sampleRate: number }
export type WaveformEvent = { event: "started"; data: { audioPath: string } } | { event: "audioInfo"; data: { sampleRate: number; durationSecs: number } } | { event: "progress"; data: { totalPeaks: number } } | { event: "chunk"; data: { peaks: number[]; offset: number } } | { event: "completed"; data: { peaks: number[]; durationSecs: number } } | { event: "error"; data: { message: string } }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
