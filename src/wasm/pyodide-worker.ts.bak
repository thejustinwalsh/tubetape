/**
 * Pyodide Web Worker
 * 
 * ARCHITECTURE (Safari-compatible, no JSPI/run_sync):
 * 
 * HTTP Requests (metadata, etc):
 * 1. Python calls queueHTTPRequest() - returns request ID immediately
 * 2. JS processes queue async via Tauri HTTP
 * 3. Python calls pollHTTPResponse(id) - returns result when ready
 * 
 * Downloads (video/audio streams):
 * 1. Python calls queueDownload() - returns download ID immediately  
 * 2. Native Tauri downloads directly to disk
 * 3. Python calls pollDownloadStatus(id) - returns completion status
 * 4. File exists on disk when done
 * 
 * FFmpeg (conversion):
 * 1. Python calls nativeFFmpegAdapter() - queues command, returns fake success
 * 2. After yt-dlp completes, JS executes FFmpeg on native side
 * 3. Output file exists on disk when done
 */

import type { PyodideInterface } from 'pyodide';
import { invoke } from '@tauri-apps/api/core';

let pyodide: PyodideInterface | null = null;
let isInitialized = false;
let verboseMode = false;

// ============================================================================
// Stdout/Stderr Streaming for Real-time Progress
// ============================================================================

type LogLevel = 'debug' | 'info' | 'warning' | 'error' | 'progress';

interface LogMessage {
  level: LogLevel;
  message: string;
  timestamp: number;
  source: 'stdout' | 'stderr' | 'yt-dlp';
}

interface DownloadProgress {
  percent: number;
  downloaded: string;
  total: string;
  speed: string;
  eta: string;
}

const logBuffer: LogMessage[] = [];
let stdoutBuffer: number[] = [];
let stderrBuffer: number[] = [];
const decoder = new TextDecoder('utf-8');
const lineDelimiters = [0x0a, 0x0d]; // \n and \r

function parseYtDlpProgress(line: string): DownloadProgress | null {
  // Parse: [download]  50.0% of 10.00MiB at 1.00MiB/s ETA 00:05
  const progressMatch = line.match(/\[download\]\s+(\d+\.?\d*)%\s+of\s+~?([\d.]+\w+)\s+at\s+([\d.]+\w+\/s)(?:\s+ETA\s+(\S+))?/);
  if (progressMatch) {
    return {
      percent: parseFloat(progressMatch[1]),
      downloaded: '',
      total: progressMatch[2],
      speed: progressMatch[3],
      eta: progressMatch[4] || 'unknown'
    };
  }
  
  // Parse: [download] Destination: /path/to/file
  // Parse: [download] 100% of 10.00MiB in 00:05
  const completeMatch = line.match(/\[download\]\s+100%\s+of\s+([\d.]+\w+)/);
  if (completeMatch) {
    return {
      percent: 100,
      downloaded: completeMatch[1],
      total: completeMatch[1],
      speed: '',
      eta: '00:00'
    };
  }
  
  return null;
}

function determineLogLevel(line: string): LogLevel {
  if (line.includes('[download]') && line.includes('%')) return 'progress';
  if (line.includes('ERROR') || line.includes('Error')) return 'error';
  if (line.includes('WARNING') || line.includes('Warning')) return 'warning';
  if (line.includes('[debug]') || line.startsWith('DEBUG')) return 'debug';
  return 'info';
}

function processOutputLine(line: string, source: 'stdout' | 'stderr'): void {
  if (!line.trim()) return;
  
  const level = source === 'stderr' ? 'error' : determineLogLevel(line);
  
  const logEntry: LogMessage = {
    level,
    message: line,
    timestamp: Date.now(),
    source: line.includes('[') ? 'yt-dlp' : source
  };
  
  logBuffer.push(logEntry);
  
  if (logBuffer.length > 1000) {
    logBuffer.shift();
  }
  
  if (verboseMode || level === 'error' || level === 'warning' || level === 'progress') {
    console.log(`[pyodide-${source}]`, line);
  }
  
  const progress = parseYtDlpProgress(line);
  if (progress) {
    self.postMessage({
      type: 'progress',
      data: progress
    });
  }
  
  self.postMessage({
    type: 'log',
    data: logEntry
  });
}

function createStdoutHandler(): { raw: (byte: number) => void } {
  return {
    raw: (byte: number) => {
      if (lineDelimiters.includes(byte)) {
        if (stdoutBuffer.length > 0) {
          const line = decoder.decode(new Uint8Array(stdoutBuffer));
          processOutputLine(line, 'stdout');
          stdoutBuffer = [];
        }
      } else {
        stdoutBuffer.push(byte);
      }
    }
  };
}

function createStderrHandler(): { raw: (byte: number) => void } {
  return {
    raw: (byte: number) => {
      if (lineDelimiters.includes(byte)) {
        if (stderrBuffer.length > 0) {
          const line = decoder.decode(new Uint8Array(stderrBuffer));
          processOutputLine(line, 'stderr');
          stderrBuffer = [];
        }
      } else {
        stderrBuffer.push(byte);
      }
    }
  };
}

function getLogBuffer(): LogMessage[] {
  return [...logBuffer];
}

function clearLogBuffer(): void {
  logBuffer.length = 0;
}

function setVerboseMode(enabled: boolean): void {
  verboseMode = enabled;
  console.log(`[pyodide-worker] Verbose mode ${enabled ? 'enabled' : 'disabled'}`);
}

// ============================================================================
// FFmpeg Capabilities Cache
// ============================================================================

interface FFmpegCapabilities {
  version: string;
  bitstreamFilters: string[];
  configuration: string;
}

let ffmpegCapabilities: FFmpegCapabilities | null = null;

const STATIC_FFMPEG_CAPABILITIES: FFmpegCapabilities = {
  version: 'ffmpeg version 5.1.4 Copyright (c) 2000-2023 the FFmpeg developers',
  bitstreamFilters: [
    'aac_adtstoasc', 'av1_frame_merge', 'av1_frame_split', 'av1_metadata',
    'chomp', 'dump_extra', 'dca_core', 'dv_error_marker', 'eac3_core',
    'extract_extradata', 'filter_units', 'h264_metadata', 'h264_mp4toannexb',
    'h264_redundant_pps', 'hapqa_extract', 'hevc_metadata', 'hevc_mp4toannexb',
    'imxdump', 'mjpeg2jpeg', 'mjpegadump', 'mp3decomp', 'mpeg2_metadata',
    'mpeg4_unpack_bframes', 'mov2textsub', 'noise', 'null', 'opus_metadata',
    'pcm_rechunk', 'pgs_frame_merge', 'prores_metadata', 'remove_extra',
    'setts', 'text2movsub', 'trace_headers', 'truehd_core', 'vp9_metadata',
    'vp9_raw_reorder', 'vp9_superframe', 'vp9_superframe_split'
  ],
  configuration: '--target-os=none --arch=x86_32 --enable-cross-compile'
};

async function initFFmpegCapabilities(): Promise<void> {
  if (ffmpegCapabilities) return;
  
  try {
    const result = await invoke<{ exit_code: number; stdout: string; stderr: string }>('ffprobe_capabilities');
    if (result.exit_code === 0) {
      ffmpegCapabilities = parseFFmpegCapabilities(result.stdout, result.stderr);
      console.log('[pyodide-worker] FFmpeg capabilities loaded from native');
      return;
    }
  } catch {
    // Fall back to static
  }
  
  ffmpegCapabilities = STATIC_FFMPEG_CAPABILITIES;
  console.log('[pyodide-worker] Using static FFmpeg capabilities');
}

function parseFFmpegCapabilities(stdout: string, stderr: string): FFmpegCapabilities {
  const filters = stdout.split('\n').filter(line => line.trim() && !line.startsWith('Bitstream'));
  const versionMatch = stderr.match(/ffmpeg version ([^\n]+)/);
  const configMatch = stderr.match(/configuration: ([^\n]+)/);
  
  return {
    version: versionMatch ? versionMatch[1] : STATIC_FFMPEG_CAPABILITIES.version,
    bitstreamFilters: filters.length > 0 ? filters : STATIC_FFMPEG_CAPABILITIES.bitstreamFilters,
    configuration: configMatch ? configMatch[1] : STATIC_FFMPEG_CAPABILITIES.configuration
  };
}

// ============================================================================
// HTTP Request Queue (Polling Pattern)
// ============================================================================

interface QueuedHTTPRequest {
  id: string;
  url: string;
  method: string;
  headers: Record<string, string>;
  body?: string | null;
  status: 'pending' | 'processing' | 'completed' | 'error';
  response?: {
    status: number;
    headers: Record<string, string>;
    body: string;
  };
  error?: string;
  queuedAt: number;
  lastActivity: number;
  timeoutMs: number;
}

interface QueuedDownload {
  id: string;
  url: string;
  outputPath: string;
  headers: Record<string, string>;
  status: 'pending' | 'processing' | 'completed' | 'error';
  bytesDownloaded?: number;
  totalBytes?: number;
  error?: string;
  queuedAt: number;
  lastActivity: number;
  timeoutMs: number;
}

const httpRequestQueue: Map<string, QueuedHTTPRequest> = new Map();
let httpRequestIdCounter = 0;
let httpProcessingPromise: Promise<void> | null = null;

/**
 * Queue an HTTP request for async processing.
 * Called synchronously from Python, returns request ID immediately.
 */
function queueHTTPRequest(
  url: string, 
  method: string, 
  headers: Record<string, string>,
  body?: string | null
): string {
  const id = `http_${++httpRequestIdCounter}`;
  
  httpRequestQueue.set(id, {
    id,
    url,
    method,
    headers,
    body,
    status: 'pending',
    queuedAt: Date.now(),
    lastActivity: Date.now(),
    timeoutMs: 5 * 60 * 1000, // 5 minutes
  });
  
  console.log(`[pyodide-worker] Queued HTTP ${method} ${url.slice(0, 60)}... (${id})`);
  
  // Trigger async processing (non-blocking)
  triggerHTTPProcessing();
  
  return id;
}

/**
 * Poll for HTTP response.
 * Called synchronously from Python, returns response or null if not ready.
 */
function pollHTTPResponse(id: string): QueuedHTTPRequest | null {
  const request = httpRequestQueue.get(id);
  if (!request) {
    console.warn(`[pyodide-worker] pollHTTPResponse: request ${id} not found`);
    return null;
  }
  
  if (request.status === 'completed' || request.status === 'error') {
    httpRequestQueue.delete(id);
    console.log(`[pyodide-worker] pollHTTPResponse(${id}): returning ${request.status} response`);
    return request;
  }
  
  return null;
}

/**
 * Returns a Promise that resolves when the HTTP request completes.
 * Uses setTimeout-based polling so JavaScript event loop can process the request.
 * Python awaits this Promise directly.
 */
function waitForHTTPResponse(id: string): Promise<QueuedHTTPRequest> {
  return new Promise((resolve, reject) => {
    const pollInterval = 100;
    const maxWaitMs = 5 * 60 * 1000;
    const startTime = Date.now();
    
    function checkResult() {
      const request = httpRequestQueue.get(id);
      
      if (!request) {
        reject(new Error(`Request ${id} not found`));
        return;
      }
      
      if (request.status === 'completed') {
        httpRequestQueue.delete(id);
        console.log(`[pyodide-worker] waitForHTTPResponse(${id}): completed`);
        resolve(request);
        return;
      }
      
      if (request.status === 'error') {
        httpRequestQueue.delete(id);
        console.log(`[pyodide-worker] waitForHTTPResponse(${id}): error`);
        resolve(request);
        return;
      }
      
      if (Date.now() - startTime > maxWaitMs) {
        request.status = 'error';
        request.error = 'Request timed out';
        httpRequestQueue.delete(id);
        resolve(request);
        return;
      }
      
      setTimeout(checkResult, pollInterval);
    }
    
    setTimeout(checkResult, pollInterval);
  });
}

/**
 * Check if an HTTP request is still pending.
 */
function isHTTPRequestPending(id: string): boolean {
  const request = httpRequestQueue.get(id);
  return request ? (request.status === 'pending' || request.status === 'processing') : false;
}

/**
 * Trigger async HTTP processing (non-blocking).
 * Uses setTimeout to ensure the async work can interleave with Python's blocking.
 */
function triggerHTTPProcessing(): void {
  if (httpProcessingPromise) {
    console.log('[pyodide-worker] HTTP processing already in progress');
    return;
  }
  
  console.log('[pyodide-worker] Scheduling HTTP queue processing...');
  
  setTimeout(() => {
    console.log('[pyodide-worker] Starting HTTP queue processing...');
    httpProcessingPromise = processHTTPQueue().finally(() => {
      console.log('[pyodide-worker] HTTP queue processing finished');
      httpProcessingPromise = null;
    });
  }, 0);
}

/**
 * Process all pending HTTP requests via Tauri.
 */
async function processHTTPQueue(): Promise<void> {
  const pending = Array.from(httpRequestQueue.values()).filter(r => r.status === 'pending');
  console.log(`[pyodide-worker] Processing ${pending.length} pending HTTP requests`);
  
  for (const request of pending) {
    request.status = 'processing';
    request.lastActivity = Date.now();
    
    console.log(`[pyodide-worker] Invoking Tauri http_request for ${request.id}: ${request.url.slice(0, 60)}...`);
    
    try {
      const response = await invoke<{
        status: number;
        headers: Record<string, string>;
        body: string;
      }>('http_request', {
        url: request.url,
        method: request.method,
        headers: request.headers,
        body: request.body,
      });
      
      console.log(`[pyodide-worker] HTTP request ${request.id} completed with status ${response.status}`);
      request.status = 'completed';
      request.response = response;
    } catch (error) {
      console.error(`[pyodide-worker] HTTP request ${request.id} failed:`, error);
      request.status = 'error';
      request.error = error instanceof Error ? error.message : String(error);
    }
  }
}

// ============================================================================
// Download Queue (Native Download to Disk)
// ============================================================================

interface QueuedDownload {
  id: string;
  url: string;
  outputPath: string;
  headers: Record<string, string>;
  status: 'pending' | 'processing' | 'completed' | 'error';
  bytesDownloaded?: number;
  totalBytes?: number;
  error?: string;
}

const downloadQueue: Map<string, QueuedDownload> = new Map();
let downloadIdCounter = 0;
let downloadProcessingPromise: Promise<void> | null = null;
let timeoutCheckInterval: number | null = null;

/**
 * Queue a download for native processing.
 * The file will be written directly to disk by Tauri.
 */
function queueDownload(
  url: string,
  outputPath: string,
  headers: Record<string, string>
): string {
  const id = `dl_${++downloadIdCounter}`;
  
  downloadQueue.set(id, {
    id,
    url,
    outputPath,
    headers,
    status: 'pending',
    queuedAt: Date.now(),
    lastActivity: Date.now(),
    timeoutMs: 10 * 60 * 1000, // 10 minutes for downloads
  });
  
  console.log(`[pyodide-worker] Queued download ${url.slice(0, 60)}... -> ${outputPath} (${id})`);
  
  triggerDownloadProcessing();
  
  return id;
}

/**
 * Poll for download status.
 */
function pollDownloadStatus(id: string): QueuedDownload | null {
  const download = downloadQueue.get(id);
  if (!download) return null;
  
  if (download.status === 'completed' || download.status === 'error') {
    downloadQueue.delete(id);
    return download;
  }
  
  return null;
}

/**
 * Check if download is still in progress.
 */
function isDownloadPending(id: string): boolean {
  const download = downloadQueue.get(id);
  return download ? (download.status === 'pending' || download.status === 'processing') : false;
}

function triggerDownloadProcessing(): void {
  if (downloadProcessingPromise) return;
  
  downloadProcessingPromise = processDownloadQueue().finally(() => {
    downloadProcessingPromise = null;
  });
}

async function processDownloadQueue(): Promise<void> {
  const pending = Array.from(downloadQueue.values()).filter(d => d.status === 'pending');
  
  for (const download of pending) {
    download.status = 'processing';
    download.lastActivity = Date.now();
    
    try {
      await invoke('download_to_file', {
        url: download.url,
        outputPath: download.outputPath,
        headers: download.headers,
      });
      
      download.status = 'completed';
    } catch (error) {
      download.status = 'error';
      download.error = error instanceof Error ? error.message : String(error);
    }
  }
}

// ============================================================================
// JS Challenge Queue (Polling Pattern)
// ============================================================================

interface QueuedJSChallenge {
  id: string;
  code: string;
  status: 'pending' | 'processing' | 'completed' | 'error';
  result?: string;
  error?: string;
  queuedAt: number;
  lastActivity: number;
  timeoutMs: number;
}

const jsChallengeQueue: Map<string, QueuedJSChallenge> = new Map();
let jsChallengeIdCounter = 0;
let jsChallengeProcessingPromise: Promise<void> | null = null;

function queueJSChallenge(code: string): string {
  const id = `jsc_${++jsChallengeIdCounter}`;
  
  jsChallengeQueue.set(id, {
    id,
    code,
    status: 'pending',
    queuedAt: Date.now(),
    lastActivity: Date.now(),
    timeoutMs: 2 * 60 * 1000,
  });
  
  console.log(`[pyodide-worker] Queued JS challenge ${id} (${code.length} chars)`);
  triggerJSChallengeProcessing();
  
  return id;
}

function pollJSChallengeResult(id: string): QueuedJSChallenge | null {
  const challenge = jsChallengeQueue.get(id);
  if (!challenge) {
    return null;
  }
  
  if (challenge.status === 'completed' || challenge.status === 'error') {
    jsChallengeQueue.delete(id);
    return challenge;
  }
  
  return null;
}

function isJSChallengePending(id: string): boolean {
  const challenge = jsChallengeQueue.get(id);
  return challenge ? (challenge.status === 'pending' || challenge.status === 'processing') : false;
}

function triggerJSChallengeProcessing(): void {
  if (jsChallengeProcessingPromise) return;
  
  jsChallengeProcessingPromise = processJSChallengeQueue().finally(() => {
    jsChallengeProcessingPromise = null;
  });
}

async function processJSChallengeQueue(): Promise<void> {
  const pending = Array.from(jsChallengeQueue.values()).filter(c => c.status === 'pending');
  
  for (const challenge of pending) {
    challenge.status = 'processing';
    challenge.lastActivity = Date.now();
    
    try {
      console.log(`[pyodide-worker] Executing JS challenge ${challenge.id}...`);
      const result = await invoke<string>('execute_js_challenge', { code: challenge.code });
      
      challenge.status = 'completed';
      challenge.result = result;
      console.log(`[pyodide-worker] JS challenge ${challenge.id} completed`);
    } catch (error) {
      challenge.status = 'error';
      challenge.error = error instanceof Error ? error.message : String(error);
      console.error(`[pyodide-worker] JS challenge ${challenge.id} failed:`, error);
    }
  }
}

// ============================================================================
// Timeout Checking
// ============================================================================

/**
 * Check for timed-out requests and mark them as error
 */
function checkTimeouts(): void {
  const now = Date.now();
  
  // Check HTTP requests
  for (const request of httpRequestQueue.values()) {
    if ((request.status === 'pending' || request.status === 'processing') && 
        (now - request.lastActivity) > request.timeoutMs) {
      request.status = 'error';
      request.error = `Request timed out after ${request.timeoutMs}ms`;
      console.warn(`[pyodide-worker] HTTP request ${request.id} timed out`);
    }
  }
  
  // Check downloads
  for (const download of downloadQueue.values()) {
    if ((download.status === 'pending' || download.status === 'processing') && 
        (now - download.lastActivity) > download.timeoutMs) {
      download.status = 'error';
      download.error = `Download timed out after ${download.timeoutMs}ms`;
      console.warn(`[pyodide-worker] Download ${download.id} timed out`);
    }
  }
  
  // Check JS challenges
  for (const challenge of jsChallengeQueue.values()) {
    if ((challenge.status === 'pending' || challenge.status === 'processing') && 
        (now - challenge.lastActivity) > challenge.timeoutMs) {
      challenge.status = 'error';
      challenge.error = `JS challenge timed out after ${challenge.timeoutMs}ms`;
      console.warn(`[pyodide-worker] JS challenge ${challenge.id} timed out`);
    }
  }
}

/**
 * Start periodic timeout checking
 */
function startTimeoutChecking(): void {
  if (timeoutCheckInterval) return; // Already started
  
  timeoutCheckInterval = self.setInterval(checkTimeouts, 30 * 1000); // Check every 30 seconds
  console.log('[pyodide-worker] Started timeout checking');
}

// ============================================================================
// FFmpeg Command Queue
// ============================================================================

export interface FFmpegCommand {
  id: string;
  command: 'ffmpeg' | 'ffprobe';
  args: string[];
  inputPath?: string;
  outputPath?: string;
  status: 'pending' | 'running' | 'completed' | 'error';
  result?: { exit_code: number; stdout: string; stderr: string };
  error?: string;
}

const ffmpegCommandQueue: FFmpegCommand[] = [];
let commandIdCounter = 0;

function queueFFmpegCommand(command: 'ffmpeg' | 'ffprobe', args: string[]): FFmpegCommand {
  const id = `ffmpeg_${++commandIdCounter}`;
  
  let outputPath: string | undefined;
  let inputPath: string | undefined;
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '-i' && i + 1 < args.length) {
      inputPath = args[i + 1];
    }
    if (i === args.length - 1 && !args[i].startsWith('-')) {
      outputPath = args[i];
    }
    if (args[i] === '-y' && i + 1 < args.length && !args[i + 1].startsWith('-')) {
      outputPath = args[i + 1];
    }
  }
  
  const cmd: FFmpegCommand = {
    id,
    command,
    args,
    inputPath,
    outputPath,
    status: 'pending'
  };
  
  ffmpegCommandQueue.push(cmd);
  console.log(`[pyodide-worker] Queued ${command} command ${id}`);
  
  return cmd;
}

async function executeQueuedFFmpegCommands(): Promise<FFmpegCommand[]> {
  const pendingCommands = ffmpegCommandQueue.filter(cmd => cmd.status === 'pending');
  
  for (const cmd of pendingCommands) {
    cmd.status = 'running';
    console.log(`[pyodide-worker] Executing ${cmd.command} command ${cmd.id}`);
    
    try {
      const result = await invoke<{ exit_code: number; stdout: string; stderr: string }>(
        'dlopen_ffmpeg',
        { command: cmd.command, args: cmd.args }
      );
      
      cmd.status = result.exit_code === 0 ? 'completed' : 'error';
      cmd.result = result;
      
      if (result.exit_code !== 0) {
        cmd.error = result.stderr || `FFmpeg exited with code ${result.exit_code}`;
      }
    } catch (error) {
      cmd.status = 'error';
      cmd.error = error instanceof Error ? error.message : String(error);
    }
  }
  
  return pendingCommands;
}

function getQueuedCommands(): FFmpegCommand[] {
  return [...ffmpegCommandQueue];
}

function clearCompletedCommands(): void {
  const toRemove = ffmpegCommandQueue.filter(cmd => 
    cmd.status === 'completed' || cmd.status === 'error'
  );
  for (const cmd of toRemove) {
    const idx = ffmpegCommandQueue.indexOf(cmd);
    if (idx >= 0) ffmpegCommandQueue.splice(idx, 1);
  }
}

// ============================================================================
// FFmpeg Adapter (Sync Return, Queues Work)
// ============================================================================

function nativeFFmpegAdapter(
  command: string, 
  args: string[]
): { exit_code: number; stdout: Uint8Array; stderr: Uint8Array } {
  console.log(`[pyodide-worker] FFmpeg ${command} sync hijack:`, args.length, 'args');

  if (command === 'ffprobe' && args.length > 0 && args[0] === '-bsfs') {
    const caps = ffmpegCapabilities || STATIC_FFMPEG_CAPABILITIES;
    const stdout = caps.bitstreamFilters.join('\n');
    const stderr = `${caps.version}\n  configuration: ${caps.configuration}`;
    
    return {
      exit_code: 0,
      stdout: new TextEncoder().encode(stdout),
      stderr: new TextEncoder().encode(stderr)
    };
  }

  if (args.includes('-version')) {
    const caps = ffmpegCapabilities || STATIC_FFMPEG_CAPABILITIES;
    return {
      exit_code: 0,
      stdout: new TextEncoder().encode(caps.version),
      stderr: new Uint8Array()
    };
  }

  const cmd = queueFFmpegCommand(command as 'ffmpeg' | 'ffprobe', args);
  
  let fakeStdout = '';
  if (cmd.outputPath) {
    fakeStdout = `Output file: ${cmd.outputPath}\n`;
  }
  
  return {
    exit_code: 0,
    stdout: new TextEncoder().encode(fakeStdout),
    stderr: new Uint8Array()
  };
}

// ============================================================================
// Worker Message Handling
// ============================================================================

interface WorkerMessage {
  id: string;
  type: 'init' | 'extract_info' | 'extract_audio' | 'execute_ffmpeg' | 'get_ffmpeg_queue' | 'set_verbose';
  payload?: unknown;
}

interface WorkerResponse {
  id: string;
  success: boolean;
  data?: unknown;
  error?: string;
}

async function findYtDlpWheel(): Promise<string> {
  const baseUrl = new URL('/pyodide/', self.location.origin).href;
  
  try {
    const pypiResponse = await fetch('https://pypi.org/pypi/yt-dlp/json');
    if (pypiResponse.ok) {
      const data = await pypiResponse.json() as { 
        info?: { version?: string };
        urls?: Array<{ packagetype: string; url: string }>;
      };
      const latestVersion = data.info?.version?.split('.').map(Number) || [0, 0, 0];
      const bundledVersion = [2025, 10, 22];
      
      if (latestVersion[0] > bundledVersion[0] || 
          latestVersion[1] > bundledVersion[1] || 
          latestVersion[2] > bundledVersion[2]) {
        const wheelInfo = data.urls?.find(u => u.packagetype === 'bdist_wheel');
        if (wheelInfo) {
          console.log('[pyodide-worker] Using latest yt-dlp from PyPI:', data.info?.version);
          return wheelInfo.url;
        }
      }
    }
  } catch {
    console.log('[pyodide-worker] PyPI check failed, using bundled wheel');
  }
  
  const response = await fetch(baseUrl);
  const html = await response.text();
  const wheelMatch = html.match(/yt_dlp-[\d.]+-py3-none-any\.whl/);
  const wheelName = wheelMatch ? wheelMatch[0] : 'yt_dlp-2025.10.22-py3-none-any.whl';
  
  console.log('[pyodide-worker] Using bundled wheel:', wheelName);
  return `${baseUrl}${wheelName}`;
}

async function loadOpenSSL(pyodideInstance: PyodideInterface): Promise<void> {
  const baseUrl = new URL('/pyodide/', self.location.origin).href;
  
  pyodideInstance.FS.mkdirTree('/usr/lib');
  
  await Promise.all(
    ['libcrypto.so', 'libssl.so'].map(async (file) => {
      const url = `${baseUrl}openssl-1.1.1w/${file}`;
      const response = await fetch(url);
      if (response.ok) {
        const data = new Uint8Array(await response.arrayBuffer());
        pyodideInstance.FS.writeFile(`/usr/lib/${file}`, data);
      }
    })
  );
  
  await pyodideInstance.loadPackage(`${baseUrl}ssl-1.0.0-cp312-cp312-pyodide_2024_0_wasm32.whl`);
  console.log('[pyodide-worker] OpenSSL + SSL loaded');
}

async function loadPythonPatches(pyodideInstance: PyodideInterface): Promise<void> {
  const baseUrl = new URL('/pyodide/patches/', self.location.origin).href;
  const patchFiles = ['jsc_provider.py', 'http_adapter.py', 'dlopen_adapter.py', 'loader.py'];
  
  pyodideInstance.FS.mkdirTree('/pyodide/patches');
  
  await Promise.all(
    patchFiles.map(async (file) => {
      const url = `${baseUrl}${file}`;
      const response = await fetch(url);
      if (response.ok) {
        const text = await response.text();
        pyodideInstance.FS.writeFile(`/pyodide/patches/${file}`, text);
        console.log(`[pyodide-worker] Loaded patch: ${file}`);
      } else {
        console.warn(`[pyodide-worker] Failed to load patch: ${file}`);
      }
    })
  );
  
  console.log('[pyodide-worker] Python patches loaded into VFS');
}

async function initPyodide() {
  if (isInitialized) return;

  console.log('[pyodide-worker] Initializing...');

  try {
    await initFFmpegCapabilities();

    const pyodideUrl = new URL('/pyodide/pyodide.mjs', self.location.origin).href;
    const indexURL = new URL('/pyodide/', self.location.origin).href;
    
    console.log('[pyodide-worker] Loading Pyodide from:', pyodideUrl);

    const { loadPyodide } = await import(/* @vite-ignore */ pyodideUrl);
    
    const ytDlpWheelUrl = await findYtDlpWheel();
    
    pyodide = await loadPyodide({ 
      indexURL,
      packages: [ytDlpWheelUrl]
    });

    console.log('[pyodide-worker] Pyodide + yt-dlp loaded');
    
    pyodide!.setStdout(createStdoutHandler());
    pyodide!.setStderr(createStderrHandler());
    console.log('[pyodide-worker] Stdout/stderr streaming enabled');
    
    await loadOpenSSL(pyodide!);
    await loadPythonPatches(pyodide!);

    await pyodide!.runPythonAsync(/*py*/`
import sys
sys.path.insert(0, '/pyodide/patches')
print(f"[pyodide] Python {sys.version}")
`);

    console.log('[pyodide-worker] Setting up patches...');
    
    await pyodide!.runPythonAsync(/*py*/`
from yt_dlp import YoutubeDL
import js

print("[pyodide] Applying patches...")

# =============================================================================
# HTTP Adapter - Calls Tauri directly via JS Promise, pumps microtasks
# =============================================================================
import subprocess

def http_request_via_tauri(url, method="GET", headers=None, body=None):
    headers = headers or {}
    request_id = js.queueHTTPRequest(url, method, headers, body)
    print(f"[pyodide] HTTP request started: {request_id}, pumping microtasks...")
    
    poll_count = 0
    while True:
        js.pumpMicrotasks()  # Pump microtask queue instead of yielding
        result = js.pollHTTPResponse(request_id)
        if result is not None:
            print(f"[pyodide] HTTP response received after {poll_count} polls, status={result.status}")
            break
        poll_count += 1
        if poll_count > 6000:
            raise Exception(f"HTTP request {request_id} timed out after 5 minutes")
    
    if result.status == 'error':
        raise Exception(f"HTTP request failed: {result.error}")
    
    return {
        'status': result.response.status,
        'headers': dict(result.response.headers) if hasattr(result.response.headers, 'to_py') else result.response.headers,
        'body': result.response.body
    }
    
    if result.status == 'error':
        raise Exception(f"HTTP request failed: {result.error}")
    
    return {
        'status': result.response.status,
        'headers': dict(result.response.headers) if hasattr(result.response.headers, 'to_py') else result.response.headers,
        'body': result.response.body
    }

# Patch yt-dlp's networking
import io
from yt_dlp.networking.common import RequestHandler, Response, register_rh, register_preference, _REQUEST_HANDLERS
from yt_dlp.networking.exceptions import RequestError

class NativeRequestHandler(RequestHandler):
    RH_KEY = "Native"
    RH_NAME = "Native"
    _SUPPORTED_URL_SCHEMES = ("http", "https")
    _SUPPORTED_FEATURES = ()
    _SUPPORTED_PROXY_SCHEMES = ()

    def _check_extensions(self, extensions):
        pass

    def _send(self, request):
        headers = dict(getattr(request, "headers", {}) or {})
        body = getattr(request, "data", None)
        method = getattr(request, "method", None) or "GET"
        
        print(f"[pyodide] NativeRequestHandler: {method} {request.url[:80]}...")
        result = http_request_via_tauri(request.url, method, headers, body)
        
        response_body = result.get('body', b'')
        if isinstance(response_body, str):
            response_body = response_body.encode('utf-8')
        
        return Response(
            io.BytesIO(response_body),
            request.url,
            result.get('headers', {}),
            status=result.get('status', 200)
        )

if 'Native' not in _REQUEST_HANDLERS:
    register_rh(NativeRequestHandler)
    
@register_preference(NativeRequestHandler)
def _native_preference(rh, request):
    return 1000000

print("[pyodide] HTTP handler patched with high priority")

# =============================================================================
# Download Adapter (Native to Disk)
# =============================================================================

def download_to_disk_with_polling(url, output_path, headers=None):
    """Download file directly to disk using native Tauri."""
    headers = headers or {}
    download_id = js.queueDownload(url, output_path, headers)
    
    while True:  # Poll indefinitely, timeout handled by JS
        result = js.pollDownloadStatus(download_id)
        if result is not None:
            if result.status == 'error':
                raise Exception(f"Download failed: {result.error}")
            return output_path
        time.sleep(1)

# Patch yt-dlp's downloader to use native download for media files
from yt_dlp.downloader.http import HttpFD

_original_real_download = HttpFD.real_download

def _patched_real_download(self, filename, info_dict):
    url = info_dict.get('url')
    if not url:
        return _original_real_download(self, filename, info_dict)
    
    # Check if this is a media download (not a small metadata request)
    filesize = info_dict.get('filesize') or info_dict.get('filesize_approx') or 0
    is_media = filesize > 1024 * 1024 or any(ext in filename.lower() for ext in ['.mp4', '.webm', '.m4a', '.mp3', '.opus', '.wav'])
    
    if is_media:
        print(f"[pyodide] Native download: {url[:60]}... -> {filename}")
        try:
            headers = {}
            if info_dict.get('http_headers'):
                headers = dict(info_dict['http_headers'])
            download_to_disk_with_polling(url, filename, headers)
            return True
        except Exception as e:
            print(f"[pyodide] Native download failed, falling back: {e}")
    
    return _original_real_download(self, filename, info_dict)

HttpFD.real_download = _patched_real_download
print("[pyodide] Download handler patched (native to disk)")

# =============================================================================
# FFmpeg Adapter (Sync Return, Queue Work)
# =============================================================================

_original_subprocess_run = subprocess.run

def _patched_subprocess_run(args, **kwargs):
    if isinstance(args, (list, tuple)) and args and args[0] in ("ffmpeg", "ffprobe"):
        command = args[0]
        ffmpeg_args = list(args[1:])
        print(f"[pyodide] FFmpeg intercepted: {command} with {len(ffmpeg_args)} args")
        
        result = js.nativeFFmpegAdapter(command, ffmpeg_args)
        
        exit_code = result.exit_code if hasattr(result, 'exit_code') else 0
        stdout = bytes(result.stdout) if hasattr(result, 'stdout') and result.stdout else b""
        stderr = bytes(result.stderr) if hasattr(result, 'stderr') and result.stderr else b""
        
        return subprocess.CompletedProcess(
            args=args,
            returncode=exit_code,
            stdout=stdout,
            stderr=stderr
        )
    
    return _original_subprocess_run(args, **kwargs)

subprocess.run = _patched_subprocess_run

from yt_dlp.utils import _utils

_original_popen_run = _utils.Popen.run

@classmethod  
def _patched_popen_run(cls, *args, **kwargs):
    if args and args[0] and args[0][0] in ("ffmpeg", "ffprobe"):
        command = args[0][0]
        ffmpeg_args = list(args[0][1:])
        print(f"[pyodide] Popen.run intercepted: {command}")
        
        result = js.nativeFFmpegAdapter(command, ffmpeg_args)
        exit_code = result.exit_code if hasattr(result, 'exit_code') else 0
        stdout = bytes(result.stdout) if hasattr(result, 'stdout') and result.stdout else b""
        stderr = bytes(result.stderr) if hasattr(result, 'stderr') and result.stderr else b""
        
        return [stdout, stderr, exit_code]
    
    return _original_popen_run(*args, **kwargs)

_utils.Popen.run = _patched_popen_run
print("[pyodide] subprocess.run and Popen.run patched")

# =============================================================================
# JS Challenge Provider (polling pattern, Safari-compatible)
# =============================================================================

from jsc_provider import register_jsc_provider
register_jsc_provider()

print("[pyodide] Runtime ready!")
`);

    isInitialized = true;
    console.log('[pyodide-worker] Initialization complete');

    // Start timeout checking for pending requests
    startTimeoutChecking();
  } catch (error) {
    console.error('[pyodide-worker] Initialization failed:', error);
    throw error;
  }
}

async function extractInfo(url: string): Promise<unknown> {
  if (!pyodide || !isInitialized) {
    throw new Error('Pyodide not initialized');
  }

  console.log('[pyodide-worker] Extracting info for:', url);
  clearCompletedCommands();

  const escapedUrl = url.replace(/'/g, "\\'");

  const result = await pyodide!.runPythonAsync(/*py*/`
from yt_dlp import YoutubeDL

ydl_opts = {
    'quiet': True,
    'no_warnings': True,
    'extract_flat': False,
    'noplaylist': True,
    'socket_timeout': 30,
}

with YoutubeDL(ydl_opts) as ydl:
    info = ydl.extract_info('${escapedUrl}', download=False)
    ydl.sanitize_info(info)
`);

  return result?.toJs?.() ?? result;
}

async function extractAudio(
  url: string, 
  outputPath: string
): Promise<{ info: unknown; ffmpegCommands: FFmpegCommand[] }> {
  if (!pyodide || !isInitialized) {
    throw new Error('Pyodide not initialized');
  }

  console.log('[pyodide-worker] Extracting audio for:', url);
  console.log('[pyodide-worker] Output path:', outputPath);

  clearCompletedCommands();

  const escapedUrl = url.replace(/'/g, "\\'");
  const escapedOutput = outputPath.replace(/'/g, "\\'");

  const result = await pyodide!.runPythonAsync(/*py*/`
from yt_dlp import YoutubeDL

ydl_opts = {
    'format': 'bestaudio/best',
    'outtmpl': '${escapedOutput}',
    'postprocessors': [{
        'key': 'FFmpegExtractAudio',
        'preferredcodec': 'mp3',
        'preferredquality': '192',
    }],
    'quiet': False,
    'no_warnings': False,
    'noplaylist': True,
    'socket_timeout': 30,
}

with YoutubeDL(ydl_opts) as ydl:
    info = ydl.extract_info('${escapedUrl}', download=True)
    ydl.sanitize_info(info)
`);

  return {
    info: result?.toJs?.() ?? result,
    ffmpegCommands: getQueuedCommands()
  };
}

async function handleMessage(event: MessageEvent<WorkerMessage>) {
  const { id, type, payload } = event.data;

  const response: WorkerResponse = {
    id,
    success: false,
  };

  try {
    switch (type) {
      case 'init':
        await initPyodide();
        response.success = true;
        response.data = { 
          initialized: true,
          ffmpegCapabilities: ffmpegCapabilities || STATIC_FFMPEG_CAPABILITIES
        };
        break;

      case 'extract_info': {
        const infoPayload = payload as { url: string };
        const infoResult = await extractInfo(infoPayload.url);
        response.success = true;
        response.data = infoResult;
      } break;

      case 'extract_audio': {
        const audioPayload = payload as { url: string; outputPath: string };
        const audioResult = await extractAudio(audioPayload.url, audioPayload.outputPath);
        response.success = true;
        response.data = audioResult;
      } break;

      case 'execute_ffmpeg': {
        const commands = await executeQueuedFFmpegCommands();
        response.success = true;
        response.data = { commands };
      } break;

      case 'get_ffmpeg_queue': {
        response.success = true;
        response.data = { commands: getQueuedCommands() };
      } break;

      case 'set_verbose': {
        const verbosePayload = payload as { enabled: boolean; clearBuffer?: boolean };
        setVerboseMode(verbosePayload.enabled);
        if (verbosePayload.clearBuffer) {
          clearLogBuffer();
        }
        response.success = true;
        response.data = { 
          verbose: verbosePayload.enabled,
          logBuffer: verbosePayload.enabled ? getLogBuffer() : []
        };
      } break;

      default:
        throw new Error(`Unknown message type: ${type}`);
    }
  } catch (error) {
    console.error('[pyodide-worker] Command failed:', type, error);
    response.success = false;
    response.error = error instanceof Error ? error.message : String(error);
  }

  self.postMessage(response);
}

// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.queueHTTPRequest = queueHTTPRequest;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.pollHTTPResponse = pollHTTPResponse;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.waitForHTTPResponse = waitForHTTPResponse;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.isHTTPRequestPending = isHTTPRequestPending;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.queueDownload = queueDownload;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.pollDownloadStatus = pollDownloadStatus;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.isDownloadPending = isDownloadPending;
// @ts-expect-error - Attaching to globalThis for Python bridge  
globalThis.nativeFFmpegAdapter = nativeFFmpegAdapter;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.queueJSChallenge = queueJSChallenge;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.pollJSChallengeResult = pollJSChallengeResult;
// @ts-expect-error - Attaching to globalThis for Python bridge
globalThis.isJSChallengePending = isJSChallengePending;

self.addEventListener('message', (event) => {
  handleMessage(event as MessageEvent<WorkerMessage>).catch((error) => {
    console.error('[pyodide-worker] Unhandled error:', error);
    self.postMessage({
      id: (event as MessageEvent<WorkerMessage>).data.id,
      success: false,
      error: String(error),
    });
  });
});

console.log('[pyodide-worker] Worker ready');
